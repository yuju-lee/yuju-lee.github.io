<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <link href="https://yuju-lee.github.io/author/judy/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://yuju-lee.github.io/" rel="alternate" type="text/html" />
  <updated>2024-08-04T01:19:23+09:00</updated>
  <id>https://yuju-lee.github.io/author/judy/feed.xml</id>

  
  
  

  
    <title type="html">Judy’s Devlog | </title>
  

  
    <subtitle>Cool developers never die</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">MSA-18. 프로젝트 회고</title>
      <link href="https://yuju-lee.github.io/logs/MSA-18-projreview/" rel="alternate" type="text/html" title="MSA-18. 프로젝트 회고" />
      <published>2024-08-03T00:00:00+09:00</published>
      <updated>2024-08-03T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/logs/MSA-18-projreview</id>
      <content type="html" xml:base="https://yuju-lee.github.io/logs/MSA-18-projreview/">&lt;h1 id=&quot;프로젝트-회고&quot;&gt;프로젝트 회고&lt;/h1&gt;
&lt;p&gt;그동안 이력서 작성과 포폴 작업으로 밀렸던 포스트를 다시 작성해야 할 것 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;프로젝트에서 조금 더 보완하고 싶은 점에 대해
우선 프로젝트를 배포하지 못 한 점이 아쉽다. 이건 그래도 추후에 할 수 있으니 쿠버네티스와 AWS를 좀 더 공부하고 해봐야 할 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;발생할만한 장애포인트에 대한 고민&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="JAVA-Springboot" />
      
        <category term="kubernetes" />
      

      
        <summary type="html">프로젝트 회고 그동안 이력서 작성과 포폴 작업으로 밀렸던 포스트를 다시 작성해야 할 것 같다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스와 쓰레드에 대한 개념 정리</title>
      <link href="https://yuju-lee.github.io/knowledge/thread/" rel="alternate" type="text/html" title="프로세스와 쓰레드에 대한 개념 정리" />
      <published>2024-08-03T00:00:00+09:00</published>
      <updated>2024-08-03T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/knowledge/thread</id>
      <content type="html" xml:base="https://yuju-lee.github.io/knowledge/thread/">&lt;center&gt;&lt;img src=&quot;https://velog.velcdn.com/images/kwontae1313/post/c6b300c2-1b2d-488a-9f80-3eafe6fc5ea2/image.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;프로세스와 쓰레드에 대해 비교하기 전, 쓰레드와 프로세스에 대한 개념을 확실하게 정리해야한다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스process-란&quot;&gt;프로세스(Process) 란?&lt;/h1&gt;
&lt;p&gt;하나 혹은 그 이상의 Thread로 실행되고 있는 컴퓨터 프로그램의 instance (독립적 개체)이다.
즉, 프로세스는 실행되고 있는 프로그램&lt;/p&gt;

&lt;h2 id=&quot;프로그램program-vs-프로세스process&quot;&gt;프로그램(Program) vs 프로세스(Process)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램(Program): 어떤 작업을 위해 실행할 수 있는 파일&lt;/li&gt;
  &lt;li&gt;프로세스(Process): 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램 또는 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적 개체)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;간단히 말해, 실행중이냐 아니느냐 차이&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-메모리의-구조&quot;&gt;프로세스 메모리의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/lijunhyeong/post/661e3653-9c3f-4905-afec-3d53775c94e9/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;code-영역&quot;&gt;Code 영역&lt;/h3&gt;
&lt;p&gt;Text 영역이라고도 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간이다.&lt;/li&gt;
  &lt;li&gt;프로그램을 시작할 때, 컴파일한 프로그램(기계어)이 저장된다. 읽기 전용(Read-Only) 이기 때문에 프로세스에서 변경할 수 없고 변경시 오류를 발생 시킨다.&lt;/li&gt;
  &lt;li&gt;코드 자체를 구성하는 메모리 영역으로 Hex 파일이나 Bin 파일 메모리이다. (이진 정보 형식이라는 얘기.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;data-영역&quot;&gt;Data 영역&lt;/h3&gt;
&lt;p&gt;필요에 의해 메모리를 동적으로 할당할 때 사용하는 메모리 영역으로 동적 메모리 영역이라고 부른다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간이다. 이 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸된다.&lt;/li&gt;
  &lt;li&gt;전역 변수 또는 static 값을 참조한 코드는 컴파일이 완료되면 data 영역의 주소값을 가르키도록 바뀐다. 전역변수가 변경 될 수도 있어 Read-Write로 되어 있다.&lt;/li&gt;
  &lt;li&gt;더 자세히 들어가면 BSS(Block Stated Symbol) 영역이 있다. 이 영역에는 초기화 되지 않은 전역변수가 저장된다. 초기화 된 전역변수는 Data 영역에 저장되어 비휘발성 메모리인 ROM에 저장되는데 이 부분은 비용이 많이 들어 RAM에 저장될 것과 ROM에 저장될 것을 구분하기 위해 영역을 구분해 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stack-영역&quot;&gt;Stack 영역&lt;/h3&gt;
&lt;p&gt;호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 영역은 함수 호출시 기록하고 함수의 수행이 완료되면 사라진다.&lt;/li&gt;
  &lt;li&gt;컴파일 시 stack 영역의 크기가 결정되기 때문에 무한정으로 할당 할 수 없기 때문에 재귀함수가 반복해서 호출되거나 함수가 지역변수를 메모리를 초과할 정도로 너무 많이 가지고 있다면 stack overflow가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heap-영역&quot;&gt;Heap 영역&lt;/h3&gt;
&lt;p&gt;프로그래머가 필요할 때마다 사용하는 메모리 영역이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 데이터 영역이라고도 할 수 있다. 메모리 주소 값에 의해서만 참조되고 사용되는 영역이기 떄문에 프로그램 동작 시(런타임)에 크기가 결정된다.&lt;/li&gt;
  &lt;li&gt;heap 영역은 런타임에 결정되지만, 자바에서는 객체가 heap영역에 생성되고 GC에 의해 정리된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로세스의-특징&quot;&gt;프로세스의 특징&lt;/h2&gt;
&lt;center&gt;&lt;img src=&quot;https://velog.velcdn.com/images/lijunhyeong/post/5a1b8133-40fc-4539-8b4e-e4c9447fe71c/image.png&quot; /&gt;&lt;/center&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)구조를 할당받게 되며, 프로세스당 최소 1개의 메인쓰레드를 가진다.&lt;/li&gt;
  &lt;li&gt;각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.&lt;/li&gt;
  &lt;li&gt;만약, 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스간의 통신(IPC, inter-process communication)을 사용해야한다.(예를 들어 pipe, file, socket)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로세스-컨텍스트&quot;&gt;프로세스 컨텍스트&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;프로세스 컨텍스트(Process Context)&lt;/strong&gt;는 운영체제가 실행 중인 프로세스를 관리하기 위해 유지하는 모든 상태 정보를 말한다. 이는 프로세스가 CPU에서 실행되는 동안 필요한 정보를 포함하며, 프로세스를 일시 중지하고 나중에 재개할 수 있도록 한다. 프로세스 컨텍스트에는 다음과 같은 요소가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스 상태(Process State)
    &lt;ul&gt;
      &lt;li&gt;프로세스가 현재 어떤 상태인지 나타낸다.&lt;/li&gt;
      &lt;li&gt;일반적으로 실행 중(running), 준비 상태(ready), 대기 상태(waiting) 등이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로세스 제어 블록(PCB, Process Control Block)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;각 프로세스의 상태 정보를 저장하는 데이터 구조&lt;/li&gt;
      &lt;li&gt;PCB에는 프로세스 ID(PID), 프로세스 상태, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보, 계정 정보 및 입출력 상태 정보가 포함된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU 레지스터
    &lt;ul&gt;
      &lt;li&gt;프로세스가 실행되는 동안 사용되는 모든 CPU 레지스터의 값.&lt;/li&gt;
      &lt;li&gt;여기에는 프로그램 카운터, 스택 포인터, 일반 목적 레지스터 등이 포함된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리 관리 정보
    &lt;ul&gt;
      &lt;li&gt;프로세스가 사용하는 메모리 영역에 대한 정보&lt;/li&gt;
      &lt;li&gt;여기에는 페이지 테이블, 세그먼트 테이블, 베이스 및 리미트 레지스터 등이 포함된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스케줄링 정보
    &lt;ul&gt;
      &lt;li&gt;프로세스 스케줄러가 사용하는 정보로, 프로세스의 우선순위, 스케줄링 큐에 대한 포인터 등이 포함된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;입출력 상태 정보
    &lt;ul&gt;
      &lt;li&gt;프로세스가 현재 수행 중인 입출력 작업에 대한 정보&lt;/li&gt;
      &lt;li&gt;여기에는 열려 있는 파일의 목록, 입출력 장치의 상태 등이 포함된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;계정 정보
    &lt;ul&gt;
      &lt;li&gt;프로세스의 소유자, CPU 사용 시간, 실제 사용 시간 등의 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;프로세스-컨텍스트-전환context-switching&quot;&gt;프로세스 컨텍스트 전환(Context Switching)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로세스 컨텍스트 전환 단계&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;현재 프로세스의 상태 저장
    &lt;ul&gt;
      &lt;li&gt;현재 실행 중인 프로세스의 모든 CPU 레지스터와 프로그램 카운터의 값을 PCB에 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 프로세스의 상태 복원
    &lt;ul&gt;
      &lt;li&gt;다음 실행할 프로세스의 PCB에서 CPU 레지스터와 프로그램 카운터의 값 복원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU 제어권 전환
    &lt;ul&gt;
      &lt;li&gt;CPU가 새로운 프로세스의 명령어를 실행하도록 제어권 전환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;컨텍스트 전환은 필수적이지만 비용이 많이 드는 작업이다. 전환 중에는 유효한 작업이 수행되지 않으므로, 가능한 최소화하는 것이 중요하며, 운영체제는 효율적인 스케줄링 알고리즘을 사용하여 컨텍스트 전환의 빈도를 최소화하려고 노력한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;쓰레드thread란&quot;&gt;쓰레드(Thread)란?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 내에서 프로세스의 자원을 이용하여 실행되는 여러 흐름의 단위&lt;/li&gt;
  &lt;li&gt;쓰레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;쓰레드는 운영체제의 스케줄러에 의해 독립적으로 관리될 수 있는 프로그래밍된 명령어의 가장 작은 시퀀스이다.&lt;/p&gt;

&lt;p&gt;또한, 하나의 프로세스는 하나 이상의 쓰레드를 갖고 있다.&lt;/p&gt;

&lt;h2 id=&quot;쓰레드의-구조&quot;&gt;쓰레드의 구조&lt;/h2&gt;
&lt;center&gt;&lt;img src=&quot;https://velog.velcdn.com/images/kwontae1313/post/cb6955c0-a59e-4055-ab8e-b1cd6791159a/image.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;프로그램 카운터, 레지스터 셋 이 두가지는 분명 프로세스의 문맥(context)의 구성정보와 일치한다. 따라서 &lt;strong&gt;쓰레드의 동작에 따라서 프로세스의 컨텍스트 또한 변경&lt;/strong&gt;될 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램 카운터 (Program Counter): 쓰레드가 다음에 실행할 명령어의 주소를 가리키는 포인터이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레지스터 집합 (Register Set): 쓰레드가 현재 실행되는 상태를 저장하는 데 사용되는 레지스터 집합이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스택 (Stack): 쓰레드에서 함수 호출 및 반환을 관리하기 위해 사용되는 스택이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 큰 구성정보 이외에도 식별을 위한 쓰레드ID, 상태, 쓰레드의 우선순위, 지역변수 등을 포함하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;쓰레드의-특징&quot;&gt;쓰레드의 특징&lt;/h2&gt;
&lt;p&gt;스레드는 독립적으로 동작하는 프로세스와 달리, 프로세스 내에서 스레드끼리 일부 메모리를 공유하여 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/kwontae1313/post/e14ae60a-49bc-4b1e-a928-0c48ce7260a6/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 공유(Shared Memory)
    &lt;ul&gt;
      &lt;li&gt;스레드는 &lt;strong&gt;프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유&lt;/strong&gt;한다.&lt;/li&gt;
      &lt;li&gt;스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;경량성(Lightweightness)
    &lt;ul&gt;
      &lt;li&gt;프로세스에 비해 &lt;strong&gt;스레드는 더 적은 자원을 사용&lt;/strong&gt;한다. 스레드는 프로세스 내에서 메모리와 자원을 공유하기 때문에, 프로세스를 생성하는 것보다 더 적은 메모리를 사용한다. 또한, 스레드 간의 전환은 프로세스 간의 전환보다 빠르기 때문에 더 경량적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상호 협력성(Cooperativeness)
    &lt;ul&gt;
      &lt;li&gt;스레드는 &lt;strong&gt;다른 스레드와 상호 협력하여 작업을 수행&lt;/strong&gt;할 수 있다. 프로세스간의 통신에서는 IPC기능을 통한 통신이 이루어지는 반면 스레드는 데이터, 힙 영역을 공유함으로 데이터를 주고 받을 수 있다. 이러한 협력성은 프로세스와는 달리 더 높은 수준의 동시성을 제공해 준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;멀티프로세스&quot;&gt;멀티프로세스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;멀티프로세스는 여러 프로세스를 동시에 실행하여 병렬 처리를 구현하는 방식&lt;/li&gt;
  &lt;li&gt;각 프로세스는 독립적으로 실행되며, 서로 다른 메모리 공간을 사용&lt;/li&gt;
  &lt;li&gt;한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;멀티쓰레드&quot;&gt;멀티쓰레드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;멀티쓰레드는 하나의 프로세스 내에서 여러 쓰레드를 동시에 실행하여 병렬 처리를 구현하는 방식&lt;/li&gt;
  &lt;li&gt;모든 쓰레드는 동일한 메모리 공간을 공유&lt;/li&gt;
  &lt;li&gt;쓰레드 간의 통신이 빠르지만, 동기화 문제를 적절히 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;프로세스와-스레드의-비교&quot;&gt;프로세스와 스레드의 비교&lt;/h1&gt;

&lt;table&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;
        &lt;th&gt;프로세스&lt;/th&gt;
        &lt;th&gt;스레드&lt;/th&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    &lt;tr&gt;
        &lt;td&gt;개념&lt;/td&gt;&lt;td&gt;프로그램이 동작중인 상태&lt;br /&gt; 운영체제로부터 자원을 할당받는 작업의 단위&lt;/td&gt;&lt;td&gt;프로세스의 실행 가능한 가장 작은 단위&lt;br /&gt;프로세스의 자원을 이용하여 실행되는 여러 흐름의 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;자원공유&lt;/td&gt;&lt;td&gt;독립적인 메모리를 가지고 있다&lt;/td&gt;&lt;td&gt;코드, 데이터, 힙 영역의 메모리를 공유한다&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;문맥교환의 비용&lt;/td&gt;&lt;td&gt;문맥교환의 비용이 크다&lt;/td&gt;&lt;td&gt;문맥교환의 비용이 적다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;동기화&lt;/td&gt;&lt;td&gt;독립적인 특징으로 동기화를 필요로 하지않는다.&lt;/td&gt;&lt;td&gt;공유자원에 대해 접근 시 동기화가 필요하다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="thread" />
      
        <category term="process" />
      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">RDBMS와 NoSQL에 대해</title>
      <link href="https://yuju-lee.github.io/knowledge/noSQLandRDBMS/" rel="alternate" type="text/html" title="RDBMS와 NoSQL에 대해" />
      <published>2024-08-03T00:00:00+09:00</published>
      <updated>2024-08-03T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/knowledge/noSQLandRDBMS</id>
      <content type="html" xml:base="https://yuju-lee.github.io/knowledge/noSQLandRDBMS/">&lt;h1 id=&quot;nosql의-정의&quot;&gt;NoSQL의 정의&lt;/h1&gt;
&lt;p&gt;NoSQL은 &lt;strong&gt;비관계형 데이터베이스 유형&lt;/strong&gt;을 가리키며 이 데이터베이스는 관계형 테이블과는 다른 형식으로 데이터를 저장한다. 그러나 NoSQL 데이터베이스는 언어마다 관습화된 API, 선언적 구조의 쿼리 언어, 쿼리별 언어를 사용하여 질의할 수 있는데, 이 데이터베이스가 not only SQL 데이터베이스라고 불리는 이유가 바로 이것이죠.&lt;/p&gt;

&lt;h2 id=&quot;nosql-데이터베이스는-어디에-사용될까&quot;&gt;NoSQL 데이터베이스는 어디에 사용될까?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;높은 확장성과 가용성이 주요 장점인 NoSQL 데이터베이스는 실시간 웹 애플리케이션 및 빅 데이터에 널리 사용&lt;/strong&gt;된다.&lt;/p&gt;

&lt;p&gt;변화하는 요구 사항에 빠르게 적응함으로써 민첩한 개발 패러다임에 자연스럽게 활용되는 이점 때문에 개발자들 역시 NoSQL을 선호한다. NoSQL 데이터베이스를 사용하면 데이터는 보다 직관적이고 이해하기 쉬운 방식 또는 애플리케이션이 사용하는 것에 가까운 방식으로 저장된다. NoSQL 스타일의 API를 사용하면 저장 또는 검색 시 데이터 변환의 필요성이 줄어들고, 또한 NoSQL 데이터베이스는 다운타임이 없는 클라우드의 이점을 완전히 누릴 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;nosql의-장점&quot;&gt;NoSQL의 장점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;스키마 유연성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;고정된 스키마가 없으며, 데이터 구조를 동적으로 변경 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수평적 확장성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터가 증가할 때 &lt;strong&gt;수평적 확장을 통해 성능을 유지&lt;/strong&gt;하고 쉽게 노드를 추가하여 데이터 분산 저장 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다양한 데이터 모델&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;키-값 저장소, 문서 저장소, 열 기반 저장소, 그래프 데이터베이스 등 다양한 모델 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;고성능&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;높은 쓰기 및 읽기 성능을 제공하여 대규모 데이터 처리에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;복제 및 분산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터 복제와 분산 기능을 통해 가용성과 내결함성을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;rdbms관계형-데이터베이스의-정의&quot;&gt;RDBMS(관계형 데이터베이스)의 정의&lt;/h1&gt;
&lt;p&gt;관계형 데이터베이스는 &lt;strong&gt;데이터가 열과 행의 테이블(또는 ‘관계’) 하나 이상에 저장되는 사전 정의된 관계로 데이터를 구성하는 정보 모음&lt;/strong&gt;으로, 이를 사용하면 서로 다른 데이터 구조가 어떻게 서로 연관되어 있는지 쉽게 확인하고 이해할 수 있다. 관계는 이러한 테이블 간의 상호작용을 기반으로 설정되는 여러 테이블 간의 논리적 연결이다.&lt;/p&gt;

&lt;h2 id=&quot;rdbms의-장점&quot;&gt;RDBMS의 장점&lt;/h2&gt;

&lt;p&gt;주요한 장점은 &lt;strong&gt;직관적인 데이터 표현 방법을 제공하고 관련 데이터 포인트에 쉽게 액세스할 수 있게 해준다는 것&lt;/strong&gt;이다. 따라서 관계형 데이터베이스는 인벤토리 추적부터 트랜잭션 데이터 처리, 애플리케이션 로깅에 이르기까지 &lt;strong&gt;대량의 정형 데이터를 관리해야 하는 조직에서 가장 많이 사용&lt;/strong&gt;된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전체 데이터베이스 구조를 변경하거나 기존 애플리케이션에 영향을 주지 않고 &lt;strong&gt;필요할 때마다 간편하게 테이블, 관계를 추가, 업데이트 또는 삭제하고 데이터를 변경할 수 있음&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ACID 규정 준수&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관계형 데이터베이스는 &lt;strong&gt;ACID(원자성, 일관성, 격리, 내구성) 성능을 지원&lt;/strong&gt;하여 오류, 실패 또는 기타 잠재적 오작동에 관계없이 &lt;strong&gt;데이터 유효성 보장&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사용 편의성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기술자가 아닌 사용자도 데이터베이스와 상호작용하는 방법을 배울 수 있는 &lt;strong&gt;SQL을 사용하여 복잡한 쿼리를 쉽게 실행할 수 있음&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공동작업&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 사용자가 동시에 데이터를 운영하고 액세스 가능&lt;/li&gt;
      &lt;li&gt;기본 제공되는 락 기능으로 &lt;strong&gt;업데이트 중에는 동시에 데이터에 액세스할 수 없음&lt;/strong&gt; (원자성 보장)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기본 제공 보안 기능&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;역할 기반 보안을 통해 데이터 액세스가 특정 사용자로 제한 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터베이스 정규화&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터 중복성을 줄이고 &lt;strong&gt;데이터 무결성을 향상시키는 정규화&lt;/strong&gt; 설계 기법 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rdbms의-정규화&quot;&gt;RDBMS의 정규화&lt;/h3&gt;

&lt;p&gt;정규화는 &lt;strong&gt;데이터베이스 설계 과정에서 데이터 중복을 줄이고 데이터 무결성을 유지하기 위해 테이블을 구조화하는 과정&lt;/strong&gt;이다. 정규화의 목적은 데이터 이상 현상을 방지하고 효율적인 데이터베이스를 구축하는 것이다. 정규화 과정은 여러 단계로 이루어지며, 각 단계는 특정 규칙을 따른다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;제 1 정규형 (1NF)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 필드가 원자 값을 가져야 함. 즉, 각 필드는 더 이상 나눌 수 없는 단일 값을 가짐.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;-- 잘못된 예: 복수 값을 가진 필드&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeName&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;PhoneNumbers&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- &quot;123-456-7890, 098-765-4321&quot;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;-- 올바른 예: 원자 값으로 분리된 필드&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeName&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmployeePhone&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;PhoneNumber&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제 2 정규형 (2NF)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;제 1 정규형을 만족하면서, 기본 키의 모든 부분에 완전 함수 종속성을 가져야 함. 부분 함수 종속성을 제거.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;-- 잘못된 예: 부분 함수 종속성&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrderDetail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;OrderID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ProductID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ProductName&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Quantity&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;-- 올바른 예: 완전 함수 종속성&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrderDetail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;OrderID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ProductID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Quantity&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Product&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ProductID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ProductName&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제 3 정규형 (3NF)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;제 2 정규형을 만족하면서, 기본 키에 이행적 함수 종속성을 제거.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;-- 잘못된 예: 이행적 함수 종속성&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;DepartmentID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;DepartmentName&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;-- 올바른 예: 이행적 함수 종속성 제거&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;EmployeeID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;DepartmentID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Department&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;DepartmentID&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;DepartmentName&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 과도한 정규화는 조인 연산을 많이 발생시켜 성능 저하를 초래할 수 있으므로 주의한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;그럼-어떤-상황에서-써야-적합할까&quot;&gt;그럼 어떤 상황에서 써야 적합할까?&lt;/h1&gt;

&lt;p&gt;관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL 데이터베이스)의 주요 차이점은 &lt;strong&gt;데이터를 저장하고 구성하는 방식&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;비관계형 데이터베이스의 데이터는 사전에 스키마를 정의하지 않아도 저장될 수 있다. 작업을 진행하는 동시에 데이터를 정의하는 방식으로 빠르게 데이터를 작성하고 반복할 수 있는 능력을 얻게된다는 얘기다. 이 데이터베이스는 그래프 기반, 열 지향, 문서 지향 또는 키-값 저장소 등 특정 비즈니스 요구 사항 수행에 적합합니다.&lt;/p&gt;

&lt;p&gt;RDBMS는 테이블이라고 불리는 데이터베이스 객체에 저장되어 있다. 테이블은 관계형 데이터 항목 모음이고, 열과 행으로 구성되는데, 이 데이터베이스에서는 스키마를 사전에 정의해야 한다. 다시 말해, 모든 열과 그와 관련된 데이터 유형이 사전에 파악되어야 애플리케이션이 데이터를 데이터베이스에 작성할 수 있다는 말이다. 이 데이터베이스는 또한 키를 사용해 여러 테이블을 연결하는 방식으로 정보를 저장한다. 그 과정에서 여러 테이블 간의 관계가 형성된다. 간단하게 요약하면 키는 특정 행을 검색하는 데 사용되며, 검사 또는 수정될 수 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 NoSQL 데이터베이스는 유연한 데이터 모델을 따르므로 자주 변경되는 데이터를 저장하거나 다양한 유형의 데이터를 처리하는 애플리케이션에 적합하다. 다만 쿼리의 복잡성이 높아지는 경우, 관계형 데이터베이스를 선택하는 것이 좋다. NoSQL 데이터베이스는 보통 복잡한 조인, 하위 쿼리 및 WHERE 절에서의 중첩 질의를 제공하지 않기 때문이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;ref&quot;&gt;Ref.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oracle.com/kr/database/nosql/what-is-nosql/&quot;&gt;Oracle: noSQL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/learn/what-is-a-relational-database?hl=ko&quot;&gt;Google: RDBMS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="NoSQL" />
      
        <category term="RDBMS" />
      

      
        <summary type="html">NoSQL의 정의 NoSQL은 비관계형 데이터베이스 유형을 가리키며 이 데이터베이스는 관계형 테이블과는 다른 형식으로 데이터를 저장한다. 그러나 NoSQL 데이터베이스는 언어마다 관습화된 API, 선언적 구조의 쿼리 언어, 쿼리별 언어를 사용하여 질의할 수 있는데, 이 데이터베이스가 not only SQL 데이터베이스라고 불리는 이유가 바로 이것이죠.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">http 프로토콜에 대한 개념 정리하기</title>
      <link href="https://yuju-lee.github.io/knowledge/http/" rel="alternate" type="text/html" title="http 프로토콜에 대한 개념 정리하기" />
      <published>2024-08-03T00:00:00+09:00</published>
      <updated>2024-08-03T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/knowledge/http</id>
      <content type="html" xml:base="https://yuju-lee.github.io/knowledge/http/">&lt;h1 id=&quot;http-프로토콜&quot;&gt;http 프로토콜&lt;/h1&gt;

&lt;p&gt;HTTP(하이퍼텍스트 전송 프로토콜, HyperText Transfer Protocol)는 웹 상에서 정보를 주고받기 위한 프로토콜로, 클라이언트와 서버 간의 통신이 가능하다. HTTP는 인터넷 상에서 가장 널리 사용되는 프로토콜 중 하나로, 웹 브라우저와 웹 서버 간의 데이터를 교환하는 데 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;http-프로토콜의-주요-특징&quot;&gt;http 프로토콜의 주요 특징&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;클라이언트-서버 모델&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;클라이언트(웹 브라우저 등)가 서버(웹 서버)에 요청(request)을 보내면, 서버는 요청에 대한 응답(response)을 반환한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;무상태 프로토콜(Stateless Protocol)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;각 요청은 서로 독립적이며, 이전 요청과 다음 요청 간의 연관성을 유지하지 않는다. 서버는 클라이언트의 상태를 저장하지 않으며, 매 요청마다 새로운 연결을 수립한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비연결형(Connectionless)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 요청을 보내고 서버가 응답을 반환하면, 그 연결은 끊어지는데, 이후 요청을 위해 새로운 연결을 생성한다. HTTP/1.1에서는 이를 보완하기 위해 지속 연결(persistent connection)을 도입했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;요청과 응답(Request and Response)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP 통신은 요청(request)과 응답(response)으로 구성된다. 클라이언트는 서버에 특정 리소스를 요청하고, 서버는 그 요청에 대한 응답을 반환한다.
        &lt;ul&gt;
          &lt;li&gt;요청: 요청 메서드, URL, 헤더, 바디로 구성&lt;/li&gt;
          &lt;li&gt;응답: &lt;strong&gt;상태 코드&lt;/strong&gt;, 헤더, 바디로 구성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;URI(Uniform Resource Identifier)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP는 리소스를 식별하기 위해 URI를 사용한다.&lt;/li&gt;
      &lt;li&gt;URI는 URL(Uniform Resource Locator)과 URN(Uniform Resource Name)을 포함한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;요청 메서드&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP는 다양한 요청 메서드를 지원하는데, 대표적인 메서드로는 GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH 등이 있다.
        &lt;ul&gt;
          &lt;li&gt;GET: 서버에서 리소스 요청&lt;/li&gt;
          &lt;li&gt;POST: 서버에 데이터를 제출해 리소스를 생성하거나 업데이트&lt;/li&gt;
          &lt;li&gt;PUT: 서버에 데이터를 제출해 리소스를 생성하거나 대체&lt;/li&gt;
          &lt;li&gt;DELETE: 서버에서 리소스 삭제&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태 코드(Status Codes)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP 응답에는 요청의 성공 여부를 나타내는 상태 코드가 포함된다. 상태 코드는 3자리 숫자로 구성되며, 1xx(정보), 2xx(성공), 3xx(리다이렉션), 4xx(클라이언트 오류), 5xx(서버 오류)로 분류된다.
        &lt;ul&gt;
          &lt;li&gt;200 OK: 요청을 성공적으로 처리&lt;/li&gt;
          &lt;li&gt;404 Not Found: 요청한 리소스를 찾을 수 없음&lt;/li&gt;
          &lt;li&gt;500 Internal Server Error: 서버에서 오류 발생&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확장성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP는 확장성이 뛰어나며, 새로운 기능을 추가하기 위해 확장이 가능합니다. 예를 들어, 쿠키(Cookie), 세션(Session), 캐싱(Caching) 등의 메커니즘을 통해 HTTP의 기능을 확장할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보안&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP 자체는 보안이 제공되지 않는 프로토콜입니다. 그러나 &lt;strong&gt;HTTPS(HyperText Transfer Protocol Secure)를 사용하여 SSL/TLS 암호화를 통해 보안을 강화할 수 있다.&lt;/strong&gt; HTTPS는 HTTP 통신을 암호화하여 &lt;strong&gt;데이터의 기밀성과 무결성을 보장&lt;/strong&gt;한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="http" />
      
        <category term="protocol" />
      

      
        <summary type="html">http 프로토콜</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">쿠키와 세션</title>
      <link href="https://yuju-lee.github.io/knowledge/cookieAndSession/" rel="alternate" type="text/html" title="쿠키와 세션" />
      <published>2024-08-03T00:00:00+09:00</published>
      <updated>2024-08-03T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/knowledge/cookieAndSession</id>
      <content type="html" xml:base="https://yuju-lee.github.io/knowledge/cookieAndSession/">&lt;h1 id=&quot;쿠키와-세션&quot;&gt;쿠키와 세션&lt;/h1&gt;
&lt;h2 id=&quot;쿠키cookie와-세션session을-사용하는-이유&quot;&gt;쿠키(Cookie)와 세션(Session)을 사용하는 이유&lt;/h2&gt;
&lt;p&gt;쿠키와 세션은 HTTP 프로토콜의 특징이자 약점을 보완하기 위해 사용한다.&lt;/p&gt;

&lt;p&gt;HTTP 프로토콜은 비연결 지향과 상태 정보를 유지하지 않는 특징을 가지고 있다. 따라서 서버와 클라이언트가 통신을 할 때 통신이 연속적으로 이어지지 않고 한 번 통신이 되면 끊어진다. 또한 통신이 끊어지면 상태정보가 유지되지 않기 때문에 매번 페이지를 이동할 때마다 로그인은 다시 하거나, 상품 선택 후 구매 페이지에서 선택한 상품의 정보가 없거나 하는 등의 문제가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이러한 문제를 해결하는 방법이 바로 쿠키와 세션이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;쿠키cookie&quot;&gt;쿠키(Cookie)&lt;/h2&gt;
&lt;p&gt;사용자가 어떤 웹 사이트를 방문할 경우, 해당 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다. HTTP에서 클라이언트의 상태 정보를 쿠키 형태로 클라이언트 PC에 저장하였다가, 필요 시 정보를 참조하거나 재사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;쿠키의-특징&quot;&gt;쿠키의 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Key-Value쌍으로 구성되어 있는 데이터 파일&lt;/strong&gt;이다.&lt;/li&gt;
  &lt;li&gt;쿠키이름, 쿠키값, 만료시간, 전송할 도메인명, 전송할 경로, 보안연결여부, HttpOnly 여부로 구성되어 있다.&lt;/li&gt;
  &lt;li&gt;도메인 당 20개의 쿠키를 가질 수 있다.&lt;/li&gt;
  &lt;li&gt;하나의 쿠키는 4KB(= 4096 byte)까지 저장이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;쿠키의-작동-방식-예시-로그인&quot;&gt;쿠키의 작동 방식 (예시: 로그인)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/octo__/post/04c9bcb8-4255-44c4-8473-842c1a6b0e7c/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 서버에 로그인을 요청한다.&lt;/li&gt;
  &lt;li&gt;서버는 클라이언트의 로그인 요청의 유효성을 확인하고(아이디와 비밀번호 검사) 응답 헤더에 쿠키를 추가한다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청 헤더에 추가하여 요청을 보낸다.
    &lt;ul&gt;
      &lt;li&gt;쿠키의 기한이 정해져 있지 않고 명시적으로 지우지 않는다면 반 영구적으로 쿠키가 남아있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;쿠키의-사용목적&quot;&gt;쿠키의 사용목적&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;세션 관리(Session Management)
    &lt;ul&gt;
      &lt;li&gt;로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야할 정보들을 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개인화(Personalization)
    &lt;ul&gt;
      &lt;li&gt;사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트래킹(Tracking)
    &lt;ul&gt;
      &lt;li&gt;사용자의 행동과 패턴을 분석하고 기록한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;쿠키의-종류&quot;&gt;쿠키의 종류&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;쿠키 종류&lt;/th&gt;&lt;th&gt;특징&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Session Cookie&lt;/td&gt;&lt;td&gt;일반적으로 만료시간(Expire Date)를 설정하고 메모리에만 저장되며, 브라우저 종료 시 쿠키를 삭제&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Persistent Cookie&lt;/td&gt;&lt;td&gt;장기간 유지되는 쿠키이다. 파일로 저장되어 브라우저 종료와 관계없이 사용할 수 있다.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Secure Cookie&lt;/td&gt;&lt;td&gt;HTTPS 프로토콜에서만 사용하며, 쿠키 정보가 암호화되어 전송된다.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Third-Party Cookie&lt;/td&gt;&lt;td&gt;방문한 도메인과 다른 도메인의 쿠키이다. 일반적으로 광고 배너 등을 관리할 때 유입 경로를 추적하기 위해 사용한다.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;쿠키값-확인-및-단점&quot;&gt;쿠키값 확인 및 단점&lt;/h3&gt;
&lt;p&gt;쿠키는 클라이언트에서 수정할 수 있기 때문에 위변조의 위험이 항상 존재한다. 따라서 &lt;strong&gt;쿠키값(value)를 암호화&lt;/strong&gt;해야 하며, 민감하거나 중요한 정보를 담지 않도록 해야한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;세션session&quot;&gt;세션(Session)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지&lt;/strong&gt;시키는 기술이다. 여기서 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말하며 브라우저가 종료되기 전까지 클라이언트의 요청을 유지한다.&lt;/p&gt;

&lt;h2 id=&quot;세션의-특징&quot;&gt;세션의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.&lt;/li&gt;
  &lt;li&gt;웹 서버에 저장되는 쿠키(세션 쿠키 / session cookie)이다.&lt;/li&gt;
  &lt;li&gt;브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되기 때문에 쿠키보다 비교적 보안적으로 우수하다.&lt;/li&gt;
  &lt;li&gt;저장 데이터에 제한이 없다.(서버 용량 허용 범위 내에서)&lt;/li&gt;
  &lt;li&gt;각 클라이언트에 고유 세션 ID(Session ID)를 부여한다. 세션 ID를 통해 클라이언트를 구분하여 각 요구에 맞는 서비스를 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;세션의-작동-방식&quot;&gt;세션의 작동 방식&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/octo__/post/43cd0113-e3d4-4139-9bf9-4c3d06e050ad/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 서버에 로그인을 요청한다.&lt;/li&gt;
  &lt;li&gt;서버는 클라이언트의 로그인 요청의 유효성을 확인하고 unique한 id를 session ID로 생성하여 저장한다.&lt;/li&gt;
  &lt;li&gt;서버가 응답할 때 응답헤더에 세션 ID를 쿠키에 추가하여 응답한다.&lt;/li&gt;
  &lt;li&gt;클라이언트는 이후 서버에 요청할 때 전달받은 세션 ID를 쿠키에 자동으로 요청 헤더에 추가하여 요청한다.&lt;/li&gt;
  &lt;li&gt;서버에서는 요청 헤더의 세션 ID 값을 찾아보고 유효한지 확인 후 요청을 처리하고 응답한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;세션의-사용목적&quot;&gt;세션의 사용목적&lt;/h2&gt;
&lt;p&gt;사용자나 다른 누군가에게 노출되면 안되는 보안적으로 중요한 정보들을 서버 안에서 다루기 위해 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;세션의-단점&quot;&gt;세션의 단점&lt;/h2&gt;
&lt;p&gt;세션의 내용은 서버에 저장되기 때문에 계속하여 늘어날 경우 서버에 부하가 발생할 수 있다.
또한 세션에 대한 정보가 서버에 있어 쿠키에 비해 비교적 속도가 느리다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;쿠키-vs-세션&quot;&gt;쿠키 vs 세션&lt;/h1&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;Cookie&lt;/th&gt;&lt;th&gt;Session&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;저장 위치&lt;/td&gt;&lt;td&gt;Client&lt;/td&gt;&lt;td&gt;Server&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;저장 형식&lt;/td&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;Object&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;만료 시점&lt;/td&gt;&lt;td&gt;쿠키 저장 시 설정&lt;br /&gt;(설정 없으면 브라우저 종료 시)&lt;/td&gt;&lt;td&gt;정확한 시점 모름&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;리소스&lt;/td&gt;&lt;td&gt;클라이언트의 리소스&lt;/td&gt;&lt;td&gt;서버의 리소스&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;용량 제한&lt;/td&gt;&lt;td&gt;한 도메인 당 20개, 한 쿠키 당 4KB&lt;/td&gt;&lt;td&gt;제한 없음&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;속도&lt;/td&gt;&lt;td&gt;쿠키에 정보가 있어 비교적 빠름&lt;/td&gt;&lt;td&gt;정보가 서버에 있어 비교적 느림&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2 id=&quot;세션와-쿠키를-모두-사용하는-이유&quot;&gt;세션와 쿠키를 모두 사용하는 이유&lt;/h2&gt;
&lt;p&gt;세션이 쿠키에 비해 보안이 높은 편이나 쿠키를 사용하는 이유는 세션은 서버에 저장되고, 서버의 자원을 사용하기 때문에 서버 자원에 한계가 있고, 속도가 느려질 수 있다. 
따라서 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여 서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="session" />
      
        <category term="cookie" />
      

      
        <summary type="html">쿠키와 세션 쿠키(Cookie)와 세션(Session)을 사용하는 이유 쿠키와 세션은 HTTP 프로토콜의 특징이자 약점을 보완하기 위해 사용한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">함수형 프로그래밍</title>
      <link href="https://yuju-lee.github.io/knowledge/functionalProgramming/" rel="alternate" type="text/html" title="함수형 프로그래밍" />
      <published>2024-08-02T00:00:00+09:00</published>
      <updated>2024-08-02T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/knowledge/functionalProgramming</id>
      <content type="html" xml:base="https://yuju-lee.github.io/knowledge/functionalProgramming/">&lt;h2 id=&quot;함수형-프로그래밍functional-programming이란&quot;&gt;함수형 프로그래밍(Functional Programming)이란?&lt;/h2&gt;

&lt;p&gt;기존의 명령형 프로그래밍을 기반으로 개발했던 개발자들은 개발하는 소프트웨어의 크기가 커짐에 따라, 복잡하게 엉켜있는 스파게티 코드를 유지보수하는 것이 매우 힘들다는 것을 깨닫게 되었다. 그리고 이를 해결하기 위해 &lt;strong&gt;함수형 프로그래밍이라는 프로그래밍 패러다임&lt;/strong&gt;에 관심을 갖게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수형 프로그래밍은 거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법&lt;/strong&gt;으로, 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functional Programming is programming without assignment satements &lt;br /&gt;- Rober C.Martin -&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;유명한 책인 클린 코드(Clean Code)의 저자 Robert C.Martin은 함수형 프로그래밍을 대입문이 없는 프로그래밍이라고 정의하였다.&lt;/p&gt;

&lt;h2 id=&quot;함수형-프로그래밍functional-programming에-대한-이해&quot;&gt;함수형 프로그래밍(Functional Programming)에 대한 이해&lt;/h2&gt;

&lt;p&gt;함수형 프로그래밍은 &lt;strong&gt;대입문을 사용하지 않는 프로그래밍&lt;/strong&gt;이며, 작은 문제를 해결하기 위한 함수를 작성한다고 한다. 함수형 프로그래밍은 무엇을(What)에 포커스를 두는 프로그래밍이며, 그렇기 때문에 함수형 프로그래밍에서는 ‘출력을 하는 함수’를 파라미터로 넘길 수 있다. 이는 함수형 프로그래밍의 기본 원리 中 함수를 1급 시민(First-Class Citizen) 또는 1급 객체(First-Class Object)로 관리하는 특징이다.&lt;/p&gt;

&lt;p&gt;명령형 프로그래밍에서는 메소드를 호출하면 상황에 따라 내부의 값이 바뀔 수 있다. 즉, 우리가 개발한 함수 내에서 선언된 변수의 메모리에 할당된 값이 바뀌는 등의 변화가 발생할 수 있다. &lt;strong&gt;하지만 함수형 프로그래밍에서는 대입문이 없기 때문에 메모리에 한 번 할당된 값은 새로운 값으로 변할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부수 효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, &lt;strong&gt;참조 투명성을 지킬 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;함수형 프로그래밍의 특징을 한 줄로 요약하면 위와 같다. 여기서 키워드는 &lt;strong&gt;“부수 효과”, “순수 함수”, “1급 객체”, “참조 투명성”&lt;/strong&gt; 인데, 각각에 대해 자세히 살펴보도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;부수효과side-effect&quot;&gt;부수효과(Side Effect)&lt;/h3&gt;
&lt;p&gt;부수효과(Side Effect)란 다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수의 값이 변경됨&lt;/li&gt;
  &lt;li&gt;자료 구조를 제자리에서 수정함&lt;/li&gt;
  &lt;li&gt;객체의 필드값을 설정함&lt;/li&gt;
  &lt;li&gt;예외나 오류가 발생하며 실행이 중단됨&lt;/li&gt;
  &lt;li&gt;콘솔 또는 파일 I/O가 발생함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;순수-함수pure-function&quot;&gt;순수 함수(Pure Function)&lt;/h3&gt;
&lt;p&gt;부수 효과(Side Effect)들을 제거한 함수들을 순수 함수(Pure Function)이라고 부르며, 함수형 프로그래밍에서 사용하는 함수는 이러한 순수 함수들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Memory or I/O의 관점에서 Side Effect가 없는 함수&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수의 실행이 외부에 영향을 끼치지 않는 함수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;순수 함수(Pure Function)의 장점&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;순수 함수(Pure Function)을 이용하면 얻을 수 있는 효과는 다음과 같다.&lt;/li&gt;
      &lt;li&gt;함수 자체가 독립적이며 Side-Effect가 없기 때문에 Thread에 안전성을 보장받을 수 있음&lt;/li&gt;
      &lt;li&gt;Thread에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1급-객체first-class-object&quot;&gt;1급 객체(First-Class Object)&lt;/h3&gt;
&lt;p&gt;1급 객체란 다음과 같은 것들이 가능한 객체를 의미한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수나 데이터 구조 안에 담을 수 있음&lt;/li&gt;
  &lt;li&gt;파라미터로 전달할 수 있음&lt;/li&gt;
  &lt;li&gt;반환값으로 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;할당에 사용된 이름과 무관, 고유하게 구별 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참조-투명성referential-transparency&quot;&gt;참조 투명성(Referential Transparency)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 인자에 대해 항상 동일한 결과를 반환해야 함&lt;/li&gt;
  &lt;li&gt;참조 투명성을 통해 기존의 값은 변경되지 않고 유지 (Immutable Data)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;명령형 프로그래밍과 함수형 프로그래밍에서 사용하는 함수는 &lt;strong&gt;부수효과의 유/무에 따라 차이가 있다.&lt;/strong&gt; 그에 따라 함수가 참조에 투명한지 안 한지 나뉘어 지는데, 참조에 투명하다는 것은 말 그대로 함수를 실행하여도 어떠한 상태의 변화 없이 항상 동일한 결과를 반환하여 항상 동일하게(투명하게) 실행 결과를 참조(예측)할 수 있다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;즉, 어떤 함수 f에 어떠한 인자 x를 넣고 f를 실행하게 되면, f는 입력된 인자에만 의존하므로 항상 f(x)라는 동일한 결과를 얻는다는 것을 의미한다. &lt;strong&gt;부작용을 제거하여 프로그램의 동작을 이해하고 예측을 용이하게 하는 것은 함수형 프로그래밍으로 개발하려는 핵심 동기 중 하나&lt;/strong&gt;이다. 그리고 이러한 부분인 병렬 처리 환경에서 개발할 때 Race Condition에 대한 비용을 줄여 준다. 왜냐, 함수형 프로그래밍에서는 값의 대입이 없이 항상 동일한 실행에 대해 동일한 결과를 반환하기 때문에.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="funtional-programming" />
      

      
        <summary type="html">함수형 프로그래밍(Functional Programming)이란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Kubernetes에 대해 알아보기</title>
      <link href="https://yuju-lee.github.io/knowledge/kubernetes/" rel="alternate" type="text/html" title="Kubernetes에 대해 알아보기" />
      <published>2024-08-02T00:00:00+09:00</published>
      <updated>2024-08-02T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/knowledge/kubernetes</id>
      <content type="html" xml:base="https://yuju-lee.github.io/knowledge/kubernetes/">&lt;h2 id=&quot;쿠버네티스란&quot;&gt;쿠버네티스란?&lt;/h2&gt;

&lt;p&gt;‘k8s’ 또는 ‘kube’라고도 하는 Kubernetes는 컨테이너화된 애플리케이션의 배포, 관리 및 확장을 예약하고 자동화하기 위한 컨테이너 오케스트레이션 플랫폼이다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너란&quot;&gt;컨테이너란?&lt;/h2&gt;
&lt;p&gt;컨테이너는 애플리케이션 소스 코드와 모든 환경에서 코드를 실행하는 데 필요한 모든 운영 체제(OS) 라이브러리 및 종속성을 결합하는 경량의 실행 가능한 애플리케이션 구성 요소이다.&lt;/p&gt;

&lt;p&gt;컨테이너는 프로세스를 격리하고 해당 프로세스가 액세스할 수 있는 CPU, 메모리, 디스크의 양을 제어하여 여러 애플리케이션이 단일 OS 인스턴스를 공유할 수 있도록 하는 운영 체제(OS) 가상화의 한 형태를 활용하는데, 컨테이너는 가상 머신(VM)보다 더 작고 리소스 측면에서 효율적이며 휴대성이 뛰어나기 때문에 최신 클라우드 네이티브 애플리케이션의 사실상의 컴퓨팅 단위로 자리 잡았다고 할 수 있다. (도커의 컨테이너 개념과 비슷하다!)&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;kubernetes를-사용한-컨테이너-오케스트레이션&quot;&gt;Kubernetes를 사용한 컨테이너 오케스트레이션&lt;/h1&gt;

&lt;p&gt;컨테이너가 확산됨에 따라(오늘날에는 한 조직에 수백, 수천 개의 컨테이너가 있을 수 있음) 운영팀은 컨테이너 배포, 네트워킹, 확장성, 가용성을 예약하고 자동화해야 했고 그렇게 컨테이너 오케스트레이션 시장이 탄생했다.&lt;/p&gt;

&lt;p&gt;다른 컨테이너 오케스트레이션 옵션, 특히 Docker Swarm과 Apache Mesos가 초기에 어느 정도 주목을 받았지만, Kubernetes는 빠르게 가장 널리 채택되었다(실제로 한 때는 오픈 소스 소프트웨어 역사상 가장 빠르게 성장하는 프로젝트이기도 했고요).&lt;/p&gt;

&lt;p&gt;개발자들은 Kubernetes의 광범위한 기능, 방대하고 성장하는 오픈 소스 지원 툴 에코시스템, 클라우드 서비스 제공업체 전반에 걸친 지원 및 이동성 때문에 Kubernetes를 선택한다.&lt;/p&gt;

&lt;h2 id=&quot;그럼-kubernetes는-어떤-기능을-할까&quot;&gt;그럼 Kubernetes는 어떤 기능을 할까?&lt;/h2&gt;
&lt;p&gt;Kubernetes는 다음을 포함하여 &lt;strong&gt;애플리케이션 라이프 사이클 전반에 걸쳐 컨테이너 관련 작업을 예약하고 자동화&lt;/strong&gt;한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배포: 지정된 수의 컨테이너를 지정된 호스트에 배포하고 원하는 상태로 계속 실행함&lt;/li&gt;
  &lt;li&gt;롤아웃: 배포를 변경하는 것이며, Kubernetes를 사용하면 롤아웃을 시작, 일시 중지, 재개 또는 롤백할 수 있음&lt;/li&gt;
  &lt;li&gt;서비스 검색: Kubernetes는 DNS 이름 또는 IP 주소를 사용하여 컨테이너를 인터넷이나 다른 컨테이너에 자동으로 노출 가능함&lt;/li&gt;
  &lt;li&gt;스토리지 프로비저닝: 필요에 따라 컨테이너에 대한 영구 로컬 또는 클라우드 스토리지를 마운트하도록 Kubernetes를 설정함&lt;/li&gt;
  &lt;li&gt;로드 밸런싱: Kubernetes 로드 밸런싱은 CPU 사용률 또는 사용자 지정 메트릭을 기반으로 네트워크 전체에 워크로드를 분산하여 성능과 안정성 유지&lt;/li&gt;
  &lt;li&gt;오토 스케일링: 트래픽이 급증하면 Kubernetes 자동 확장은 필요에 따라 새 클러스터를 스핀 업하여 추가 워크로드 처리&lt;/li&gt;
  &lt;li&gt;고가용성을 위한 자가 치료: 컨테이너에 장애가 발생하면 Kubernetes는 자동으로 컨테이너를 재시작하거나 교체하여 중단 시간을 방지하며, 또한 상태 확인 요구 사항을 충족하지 않는 컨테이너를 삭제할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;쿠버네티스의-특징&quot;&gt;쿠버네티스의 특징&lt;/h2&gt;

&lt;h3 id=&quot;1-다양한-배포-방식&quot;&gt;1. 다양한 배포 방식&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/c3737747-b4af-4d22-b5aa-5dc43f3b9ecb/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Deployment, StatefulSets, DaemonSet, Job, CronJob 등 다양한 배포 방식을 지원&lt;/li&gt;
  &lt;li&gt;여러대의 애플리케이션을 띄우고 싶을 경우에는 Deployment 이용&lt;/li&gt;
  &lt;li&gt;로그나 모니터링 등 모든 서버에 설치가 필요한 경우엔 DaemonSet을 이용&lt;/li&gt;
  &lt;li&gt;배치성 작업은 Job이나 CronJob을 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-namespace--label&quot;&gt;2. Namespace &amp;amp; Label&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/890af825-10ee-4e77-b71c-dcc5dc55c83a/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;네임스페이스(Namespace) 기능으로 하나의 클러스터를 논리적으로 구분하여 사용 가능&lt;/li&gt;
  &lt;li&gt;라벨(label) 기능으로 유연하면서 확장성 있게 리소스를 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-rbac-role-based-access-control&quot;&gt;3. RBAC (role-based access control)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/e3f80335-fb23-47e3-8934-7cdd034ea746/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;역할 기반 액세스 제어&lt;/li&gt;
  &lt;li&gt;누가(주체), 무엇을(동사), 어디에(네임스페이스) 실행할 수 있는지 결정하는 권한 또는 템플릿 집합을 수반하는 Identity 및 액세스 관리 형식&lt;/li&gt;
  &lt;li&gt;각각의 리소스에 대해 유저별로 CRUD스러운 권한을 손쉽게 지정&lt;/li&gt;
  &lt;li&gt;클러스터 전체에 적용하거나 특정 네임스페이스에 적용&lt;/li&gt;
  &lt;li&gt;AWS의 경우 IAM을 연동해서 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-auto-scaling&quot;&gt;4. Auto Scaling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;손쉽게 리소스 확장 가능&lt;/li&gt;
  &lt;li&gt;Horizontal Pod Autoscaling(HPA) : CPU, MEM 사용량에 따라 Pod 수평 확장 기능&lt;/li&gt;
  &lt;li&gt;Vertical Pod Autoscaling(VPA) : Pod 리소스 할당량 조정 (CPU, memory..)&lt;/li&gt;
  &lt;li&gt;Cluster Autoscaling(CA) : 노드(서버) 개수 조정 가능 (클라우드 환경에서만)&lt;/li&gt;
  &lt;li&gt;이 외에도 KEDA 라는 오픈소스를 활용하여 HTTP 요청량이나 이벤트 수에 따라 Pod를 스케일링할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-federation-multi-cluster&quot;&gt;5. Federation, Multi Cluster&lt;/h3&gt;
&lt;p&gt;클라우드에 설치한 쿠버네티스 클러스터와 자체 서버에 설치한 쿠버네티스를 묶어서 하나로 사용 가능
구글의 Anthos를 이용하면 한 곳에서 여러 클라우드의 쿠버네티스 클러스터들을 관리 가능&lt;/p&gt;

&lt;h2 id=&quot;쿠버네티스-기본-개념과-구성-요소&quot;&gt;쿠버네티스 기본 개념과 구성 요소&lt;/h2&gt;

&lt;h3 id=&quot;마스터---노드-구조&quot;&gt;마스터 - 노드 구조&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/843b1f0b-f4f8-476b-b80b-50587c6f5f22/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;중앙(Master)에 API 서버와 상태 저장소를 두고 각 서버(Node) 의 에이전트(kubelet)과 통신하는 단순한 구조&lt;/li&gt;
  &lt;li&gt;모든 명령은 마스터의 API 서버를 호출하고, 노드는 마스터와 통신하면서 필요한 작업 수행&lt;/li&gt;
  &lt;li&gt;Kubectl 이라는 Client 도구로 API 서버 접근 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;desired-state&quot;&gt;Desired State&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/03c3be54-9d7a-4550-92be-c344657b4483/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;관리자가 서버를 배포할 때 직접적인 동작을 명령하지 않고 원하는 상태를 선언하는 방식을 사용 (RUN x, Create o)
    &lt;ul&gt;
      &lt;li&gt;A 컨테이너를 실행해 줘. 그리고 80 포트로 오픈해 줘. -&amp;gt; 현재 상태를 원하는 상태로 바꾸기 위한 명령(imperative)&lt;/li&gt;
      &lt;li&gt;80 포트를 오픈한 A 컨테이너를 1개 유지해 줘. -&amp;gt; 원하는 상태를 선언(declarative)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Desired State (원하는 상태)
    &lt;ul&gt;
      &lt;li&gt;관리자가 바라는 환경 (구체적으로 웹서버 몇개 띄울건지, 몇번 포트로 띄울건지)&lt;/li&gt;
      &lt;li&gt;현재 상태(current state) 를 모니터링하면서 관리자가 설정한 원하는 상태(desired state)를 유지하는 방향으로 동작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿠버네티스의 핵심은 상태이며 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 알아야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes-object&quot;&gt;Kubernetes Object&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;POD&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/85c6c7ab-7d2d-434e-9e93-ddf281e5ac8d/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;쿠버네티스에서 배포할 수 있는 가장 작은 단위&lt;/li&gt;
      &lt;li&gt;한 개 이상의 컨테이너와 스토리지, 네트워크 속성 가짐&lt;/li&gt;
      &lt;li&gt;컨테이너를 하나만 사용하는 경우도 반드시 Pod으로 감싸서 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Replicaset &amp;amp; Deployment&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/holicme7/post/d8f2ad0e-0e6e-46b9-9e6b-38dab0822fd7/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Pod을 여러 개(한 개 이상) 복제하여 관리하는 오브젝트&lt;/li&gt;
      &lt;li&gt;복제할 개수, 개수를 체크할 라벨 선택자, 생성할 Pod의 설정값(템플릿)등 설정&lt;/li&gt;
      &lt;li&gt;자동으로 롤링 업데이트 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Service&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;네트워크 관련 Object&lt;/li&gt;
      &lt;li&gt;Pod &amp;lt;-&amp;gt; Pod 연결, 외부에서 접근할때 등등 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes-object-spec-기술---manifest-파일&quot;&gt;Kubernetes Object Spec 기술 - Manifest 파일&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;오브젝트의 명세Spec, 상태desired state 정의는 YAML 파일로 정의&lt;/li&gt;
  &lt;li&gt;오브젝트의 종류와 원하는 상태를 입력&lt;/li&gt;
  &lt;li&gt;배포 노드나 RBAC(접근 권한 설정) 도 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes-배포-방식&quot;&gt;Kubernetes 배포 방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션을 배포하기 위해 오브젝트(object)에 라벨Label 을 붙여 원하는 상태(desired state) 로 정의(yaml)하고 API 서버에 전달하는 방식을 사용&lt;/li&gt;
  &lt;li&gt;yaml 파일을 만들어서, 쿠버네티스 API 서버에 전달하면 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;ref&quot;&gt;Ref.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/kr-ko/topics/kubernetes&quot;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@holicme7/K8s-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot;&gt;쿠버네티스란 무엇인가?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="Kubernetes" />
      

      
        <summary type="html">쿠버네티스란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[Algorithm] Union find</title>
      <link href="https://yuju-lee.github.io/algorithm/algorithm-unionFind/" rel="alternate" type="text/html" title="[Algorithm] Union find" />
      <published>2024-07-15T00:00:00+09:00</published>
      <updated>2024-07-15T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/algorithm/algorithm-unionFind</id>
      <content type="html" xml:base="https://yuju-lee.github.io/algorithm/algorithm-unionFind/">&lt;h2 id=&quot;유니온-파인드union-find-서로소-집합&quot;&gt;유니온 파인드(Union-find, 서로소 집합)&lt;/h2&gt;

&lt;p&gt;유니온 파인드(Union-Find) 알고리즘, 또는 서로소 집합(Disjoint Set) 자료구조는 동적 연결성 문제를 해결하기 위해 사용된다. 이 자료구조는 주로 그래프에서 연결된 컴포넌트를 찾는 데 사용되는데, 유니온 파인드 자료구조는 두 가지 주요 연산을 효율적으로 수행한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Union: 두 개의 집합을 하나의 집합으로 합친다.&lt;/li&gt;
  &lt;li&gt;Find: 특정 원소가 속한 집합을 찾는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;유니온 파인드의 주요 개념&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;집합 표현:
    &lt;ul&gt;
      &lt;li&gt;각 원소는 자신을 부모로 가지는 트리 형태로 표현된다.&lt;/li&gt;
      &lt;li&gt;집합의 루트 노드는 집합의 대표(또는 루트)로 간주된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Find 연산:
    &lt;ul&gt;
      &lt;li&gt;주어진 원소가 속한 집합의 대표를 찾는다.&lt;/li&gt;
      &lt;li&gt;경로 압축(Path Compression)을 통해 트리의 높이를 줄여, 이후의 Find 연산이 더 빠르게 수행되도록 최적화할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Union 연산:
    &lt;ul&gt;
      &lt;li&gt;두 개의 집합을 하나로 합친다.&lt;/li&gt;
      &lt;li&gt;Union by Rank 또는 Union by Size 기법을 사용하여 트리의 높이를 최소화할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;유니온 파인드의 최적화 기법&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;경로 압축(Path Compression):
    &lt;ul&gt;
      &lt;li&gt;Find 연산을 수행하는 동안, 방문한 모든 노드를 직접 루트 노드에 연결하여 &lt;strong&gt;트리의 높이를 줄인다&lt;/strong&gt;.&lt;/li&gt;
      &lt;li&gt;이 최적화는 Find 연산의 시간 복잡도를 거의 상수 시간으로 만든다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;랭크에 의한 합치기(Union by Rank):
    &lt;ul&gt;
      &lt;li&gt;각 트리의 높이를 추적하고, 항상 높이가 낮은 트리를 높이가 높은 트리 아래에 연결하여 트리의 높이를 최소화한다.&lt;/li&gt;
      &lt;li&gt;이는 트리의 균형을 유지하는 데 도움이 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;크기에 의한 합치기(Union by Size):
    &lt;ul&gt;
      &lt;li&gt;각 집합의 크기를 추적하고, 항상 작은 트리를 큰 트리 아래에 연결하여 트리의 높이를 최소화한다.&lt;/li&gt;
      &lt;li&gt;이는 Union by Rank와 유사하게 트리의 균형을 유지하는 데 도움이 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;시간 복잡도&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;경로 압축과 랭크에 의한 합치기 최적화를 적용하면 유니온 파인드 자료구조의 연산은 거의 상수 시간으로 수행되는데, 정확히는 매우 느리게 증가하는 역 아커만 함수(inverse Ackermann function) 시간 복잡도인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(α(n))&lt;/code&gt;으로 수행한다. 이 함수는 &lt;strong&gt;실제로는 거의 상수로 간주&lt;/strong&gt;될 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      
        <category term="Union-find" />
      

      
        <summary type="html">유니온 파인드(Union-find, 서로소 집합)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">MSA-17. 구매 오픈 시각 기능 구현</title>
      <link href="https://yuju-lee.github.io/logs/MSA-17-schduler/" rel="alternate" type="text/html" title="MSA-17. 구매 오픈 시각 기능 구현" />
      <published>2024-07-09T00:00:00+09:00</published>
      <updated>2024-07-09T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/logs/MSA-17-schduler</id>
      <content type="html" xml:base="https://yuju-lee.github.io/logs/MSA-17-schduler/">&lt;p&gt;결제 진입 메서드에 단순히 요청 시각과 구매 오픈 시각을 비교하는 로직을 추가했다. 그리고 엔드포인트를 통해 관리자가 특정 제품에 대한 StartTime을 지정할 수 있게 한다. 구매 오픈 시각이 설정된 제품은 비교 로직을 통해 구매 시간 전 결제를 할 수 없게 구현하였다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt; // 특정 제품의 판매 시작 시간 확인
        LocalTime saleStartTime = saleTimeRepository.getProductSaleTime(productId);
        LocalTime now = LocalTime.now();
        if (saleStartTime != null &amp;amp;&amp;amp; now.isBefore(saleStartTime)) {
            return &quot;결제는 &quot; + saleStartTime.toString() + &quot;부터 가능합니다.&quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;@PostMapping(&quot;/sale-time/{productId}&quot;)
public String setProductSaleTime(@PathVariable int productId, @RequestParam String saleTime) {
    LocalTime saleStartTime = LocalTime.parse(saleTime, DateTimeFormatter.ofPattern(&quot;HH:mm&quot;));
    saleTimeRepository.setProductSaleTime(productId, saleStartTime);
    return &quot;Sale start time for product &quot; + productId + &quot; set to &quot; + saleStartTime.toString();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://yuju-lee.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F44912d2a-41d8-4efb-a178-49f42e164aad%2F7b3d4949-62a1-466f-b07e-65c16d9ac684%2FScreenshot_2024-07-09_at_6.38.13_PM.png?table=block&amp;amp;id=7964d64f-88fc-42f8-820f-198c6a4aa377&amp;amp;spaceId=44912d2a-41d8-4efb-a178-49f42e164aad&amp;amp;width=2000&amp;amp;userId=&amp;amp;cache=v2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오픈할 제품 id와 시각을 이렇게 Param으로 요청할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://yuju-lee.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F44912d2a-41d8-4efb-a178-49f42e164aad%2F56c5750a-c1ee-42c4-a25e-5306f2da4785%2FScreenshot_2024-07-09_at_6.38.35_PM.png?table=block&amp;amp;id=ba858a55-c8e0-434b-a8dd-1267f9a39dc1&amp;amp;spaceId=44912d2a-41d8-4efb-a178-49f42e164aad&amp;amp;width=2000&amp;amp;userId=&amp;amp;cache=v2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결제 시각 전의 결제 요청을 아예 거부한다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="Test-tool" />
      
        <category term="LuaScript" />
      
        <category term="JAVA-Springboot" />
      

      
        <summary type="html">결제 진입 메서드에 단순히 요청 시각과 구매 오픈 시각을 비교하는 로직을 추가했다. 그리고 엔드포인트를 통해 관리자가 특정 제품에 대한 StartTime을 지정할 수 있게 한다. 구매 오픈 시각이 설정된 제품은 비교 로직을 통해 구매 시간 전 결제를 할 수 없게 구현하였다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">MSA-16. 루아스크립트 로직 전환</title>
      <link href="https://yuju-lee.github.io/logs/MSA-16-changedProcess/" rel="alternate" type="text/html" title="MSA-16. 루아스크립트 로직 전환" />
      <published>2024-07-09T00:00:00+09:00</published>
      <updated>2024-07-09T00:00:00+09:00</updated>
      <id>https://yuju-lee.github.io/logs/MSA-16-changedProcess</id>
      <content type="html" xml:base="https://yuju-lee.github.io/logs/MSA-16-changedProcess/">&lt;p&gt;처음 가상대기열 로직에 대해 어떻게 생각했냐면… 친구들이 좋아하는 가수나 축구, 야구 티켓팅을 매번 도와달라고 해서 (별로 잘하지도 않는데도) 인터파크나 여타 다른 사이트의 티켓팅을 경험해 본 적이 좀 있다. 그래서 내가 티켓팅을 했을 때의 그 프로세스를 그대로 구현하면 어떨까, 라는 생각으로 기획했던 구조가 가상 대기열이라는 구조였다. 놀이공원처럼 큐로 대기열을 제한하고, 재고가 풀리면 다시 그 대기열에 요청을 받아서 선착순 (재고수량) 명만 결제할 수 있게끔…? 취소가 생기면 취소 재고만큼 다시 대기열을 비우고 그 대기열을 다시 채우는 방향으로 생각했다.&lt;/p&gt;

&lt;p&gt;다만, 혼자서 너무 오래 생각한 나머지 다른 시선으로 봤을 때 문제가 있진 않을까 - 내가 내 기획에 매몰되어있진 않을까 하는 염려에 멘토님께 해당 로직을 설명드리고 어떻게 생각하시냐 여쭤 봤더니 보통은 분산 락으로 구현한다고는 하나 내가 생각한 로직이 될지 안 될지는 테스트를 직접 해봐야 알 것 같다고 하셨다. 그래서 테스트 툴을 구축해 두 로직을 전부 테스트했다. 이전 테스트 결과에서처럼 분산락은 10개가 성공하였고, 가상대기열 테스트는 실제 재고는 차감되지만 동시성이 보장되지 않아 큐에는 들어갔다. 그러나 결제 프로세스까지 넘어가질 못 했다. 해당 로직은 동시성 보장이 어려웠고, 테스트 결과는 모두 실패했다. 그래서 분산락으로 선택하였으나… &lt;strong&gt;분산락 테스트 과정에서 이상한 점을 발견&lt;/strong&gt;했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://yuju-lee.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F44912d2a-41d8-4efb-a178-49f42e164aad%2Fd449b6d8-6955-4b60-83da-b7ed5ad239cb%2FScreenshot_2024-07-10_at_12.53.25_AM.png?table=block&amp;amp;id=8e0b5ff2-2fe2-4ca7-9362-5f44c08fad28&amp;amp;spaceId=44912d2a-41d8-4efb-a178-49f42e164aad&amp;amp;width=1740&amp;amp;userId=&amp;amp;cache=v2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 결과를 보면 무려 42번째로 누른 사람이 가져가버리는 불상사 발생한다. 또한 E열이 요청 시각인데, 보면 밀리세컨드엔 확실히 시간차가 있다.&lt;/p&gt;

&lt;p&gt;지금까지 분산 락으로 구현했던 로직의 테스트 결과를 봤는데, 위와 같이 &lt;strong&gt;선착순 구매가 되지 않는 것&lt;/strong&gt; 이었다. 락을 캐치하는 건 결국 랜덤이었던 것… ㅠㅠ 그래서 먼저 접속한(물론 동시라고는 하지만 밀리세컨드에서 차이가 나 요청에는 전부 순서가 있다) 사람이 락을 가져가지 못 해 구매하지 못 하고 있었다. 결국 &lt;strong&gt;결과적으론 10명에게 판매가 되었으나 구매 과정에선 엄밀히 말해 선착순은 아니었다!&lt;/strong&gt; 이는 E-commerce 도메인에서는 꽤나 리스크가 크다고 생각했다. 그리고 가장 처음 테스트했던 건 23초나 걸렸다. 그래서 로직을 다시 변경하였다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;to-be&quot;&gt;To-be&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;분산 락 제거&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Lua 스크립트의 원자성을 이용하여 &lt;strong&gt;분산 락 없이 동시성을 제어&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lua 스크립트 적용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;재고 확인, 감소, 주문 생성을 하나의 원자적 연산으로 수행&lt;/li&gt;
      &lt;li&gt;Redis에서 모든 작업을 수행해 성능이 향상시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비동기 처리&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;주문 처리와 재고 동기화를 비동기적으로 수행하여 &lt;strong&gt;응답 시간 개선&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;롤백 처리&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;결제 실패 시 Lua 스크립트를 사용해 재고 복구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://yuju-lee.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F44912d2a-41d8-4efb-a178-49f42e164aad%2Feee648d6-9ec5-4097-a6ce-bf3629b8e49f%2FScreenshot_2024-07-10_at_1.15.48_AM.png?table=block&amp;amp;id=1a1b3c16-93a8-456e-a130-50faea865649&amp;amp;spaceId=44912d2a-41d8-4efb-a178-49f42e164aad&amp;amp;width=1770&amp;amp;userId=&amp;amp;cache=v2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결국 레디스의 리스트를 다시 사용하고, Lua스크립트를 통해 동시 작업을 진행하여 리스트 사용 + Lua스크립트의 원자성을 통해 동시성을 보장했다. 기획했던 처음의 로직과 비슷하다. 다만 처음 로직과 다른 점은 lua 스크립트를 이용해 재고 확인, 감소, 주문 생성을 동시에 관리하는 부분이다.&lt;/p&gt;

&lt;p&gt;추후 주문이 완료되었을 때 Kafka를 통해 SQL 내 재고 차감 이벤트를 발행하는 Write-back 로직은 그대로 가져갔다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;test-result-summary&quot;&gt;Test Result Summary&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;TPS
    &lt;ul&gt;
      &lt;li&gt;As-is: 175.76&lt;/li&gt;
      &lt;li&gt;To-be: 235.38&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;→ 기존 로직 &lt;strong&gt;대비 ▲33.92% 향상&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Test Takt time(Average, sec)
    &lt;ul&gt;
      &lt;li&gt;As-is: 23.63681054&lt;/li&gt;
      &lt;li&gt;To-be: 11.17878842&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;→ 10000건의 요청 완료 시간 ▼52.71% 감소&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;request duration(Average, sec)
    &lt;ul&gt;
      &lt;li&gt;As-is: 0.2293712116&lt;/li&gt;
      &lt;li&gt;To-be: 0.1102334264&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;→ 10000건 개별 요청 응답 시간 ▼51.94% 감소&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;테스트 결과도 잘 확인되었다. 추가적으로 로컬에서 실행하였기 때문에 메모리 점유율, CPU 점유율 등도 확인해 봐야 한다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>judy</name>
        
        
      </author>

      

      
        <category term="Test-tool" />
      
        <category term="LuaScript" />
      
        <category term="JAVA-Springboot" />
      

      
        <summary type="html">처음 가상대기열 로직에 대해 어떻게 생각했냐면… 친구들이 좋아하는 가수나 축구, 야구 티켓팅을 매번 도와달라고 해서 (별로 잘하지도 않는데도) 인터파크나 여타 다른 사이트의 티켓팅을 경험해 본 적이 좀 있다. 그래서 내가 티켓팅을 했을 때의 그 프로세스를 그대로 구현하면 어떨까, 라는 생각으로 기획했던 구조가 가상 대기열이라는 구조였다. 놀이공원처럼 큐로 대기열을 제한하고, 재고가 풀리면 다시 그 대기열에 요청을 받아서 선착순 (재고수량) 명만 결제할 수 있게끔…? 취소가 생기면 취소 재고만큼 다시 대기열을 비우고 그 대기열을 다시 채우는 방향으로 생각했다.</summary>
      

      
      
    </entry>
  
</feed>
