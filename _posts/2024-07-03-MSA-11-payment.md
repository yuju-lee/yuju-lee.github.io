---
layout: post
title: "MSA-11. 대용량 트래픽 처리 방법에 대한 프로젝트 기획"
tags: [Kafka, Redis, Transaction, JAVA-Springboot]
author: judy
published: true
categories: [logs]
date: 2024-07-03
---

대용량 트래픽 처리에 대한 경험이 없어 기획부터 어려웠다. 그래도 어떻게 처리할 것인지 예상되는 로직을 기획하고 구현해 보려고 한다.


### *IDEA*

가상 대기열을 사용하여 구매 오픈하자마자 접속한 초기 접속자를 관리하고, 결제 시에는 Redis를 사용하여 재고를 빠르게 확인하며, 예약 상태를 통해 결제 프로세스 관리

**구매 버튼을 누르면** 

1. **가상 대기열에 추가**: 사용자가 결제 요청을 보낼 때 가상 대기열에 추가되어 재고 서비스에 재고 확인 요청 보낸 뒤 재고 서비스에서 재고를 확인하고, 재고가 충분하면 **재고 예약**
    1. 재고가 없을 시 대기열 추가 X → 구매 예약으로 이동
2. **대기열에서 처리**: 대기열에서 차례가 되면 결제 요청 서비스로 보내 결제 처리 시작
3. **결제 처리**: 결제 서비스에서 결제를 처리하고, 결제가 성공하면 최종적으로 주문 확정
    1. 결제가 실패하면 재고 예약을 취소하고, 주문 취소
4. **상태 업데이트**: 각 서비스는 상태를 성공으로 업데이트하고, 이벤트를 발행해 OrderService로 발송

- 모든 재고가 소진(품절)되면 구매 예약을 걸어 놓을 수 있으며, 취소 재고 발생 시 예약자에게 이메일로 알림 > 이후 위의 로직을 다시 적용


----

## 가상 대기열

![Untitled](https://yuju-lee.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F44912d2a-41d8-4efb-a178-49f42e164aad%2F3cec5d45-1253-40d4-b2d8-46a077552762%2FUntitled.png?table=block&id=68f4fb32-ded7-4723-9c61-4fa0b912ef84&spaceId=44912d2a-41d8-4efb-a178-49f42e164aad&width=770&userId=&cache=v2)

### 개념

- **사용자 요청 수집**: 모든 사용자가 한 번에 서버에 접속하지 않도록 요청을 대기열에 수집함
    - 특정 n 개 이상의 요청이 들어올 경우, 가상 대기열을 생성하는 로직으로 이동해야 할 듯
    - 그럼 “어떤 기준” 시간에 “n개의 요청”이 들어오는지 감시하는 로직도 필요할 것 같음
- **순차 처리**: 대기열에서 순차적으로 요청을 꺼내어 처리
- **상태 관리**: 대기열의 상태를 사용자에게 실시간 업데이트

### 설계

- DB 구조
    - **Queue Table**
        - id: 고유 식별자 (PK)
        - memberEmail: 사용자 식별자
        - requestTime: 요청 시간
        - status: 요청 상태
        - position: 대기열에서의 위치
- 로직
    1. **요청 수집**
        - 사용자가 서버에 요청을 보내면 요청을 대기열 테이블에 저장
    2. **대기열 상태 확인**
        - 사용자가 요청할 때마다 새로운 대기열 위치 및 예상 대기 시간 반환
    3. **요청 처리**
        - 백그라운드 작업을 통해 대기열에서 순차적으로 요청을 가져와 처리
        - 처리 후 상태 업데이트 → 사용자에게 결과 통지

----

## 분산 트랜잭션

### Saga 패턴

Saga 패턴은 긴 실행 시간 트랜잭션을 여러 개의 작은 트랜잭션으로 나누어 처리하는 방법이다. 각 단계는 독립적인 로컬 트랜잭션으로 처리되며, 실패 시 보상 트랜잭션을 실행하여 시스템의 일관성을 유지할 수 있다.

----

## 레디스 활용

1. **결제 생성 요청 처리**
    - **Order Service**는 클라이언트로부터 주문 요청을 받으면 요청된 각 상품에 대해 Redis에서 재고 확인
2. **원자적 재고 감소**
3. **결제 처리**
    - **Payment Service**는 결제 요청을 처리
    - 결제 성공 시 재고 업데이트를 확정
    - 결제 실패 시 Redis에서 원자적으로 재고 복원

→ Lua 스크립트 사용하기

----

![](https://yuju-lee.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F44912d2a-41d8-4efb-a178-49f42e164aad%2Fae6bf094-d7d2-464e-be75-6f85042f8f64%2FIMG_0265.png?table=block&id=b62775cf-72e8-4c23-acca-4b1670dda2d9&spaceId=44912d2a-41d8-4efb-a178-49f42e164aad&width=1440&userId=&cache=v2)
(너무 대충 그렸다...)

1. **ProductService**:
    - Redis와 MySQL을 동기화하여 재고를 관리하고, Kafka를 통해 재고 증감 구독
2. **PaymentQueueService**
    - 결제 요청을 받아 Redis에서 재고를 확인하고, 재고가 충분할 경우 요청을 대기열에 추가
3. **PaymentService**:
    - 대기열을 주기적으로 확인하여 결제 요청을 처리하고, 20% 확률로 결제를 실패
    - 결제가 성공하면 order-request-topic으로 정보를 전송, 실패 시 재고 복구 후 실패 응답 반환
4. **OrderService**:
    - order-request-topic에서 결제 성공 정보를 받아 주문을 생성